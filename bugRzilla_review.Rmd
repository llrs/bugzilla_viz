---
title: "R bugzilla review"
author: "Piyush Kumar"
advisors: "Lluís Revilla, Heather Turner"
date: "`r format(Sys.time(), '%d %B %Y')`"
output:
    prettydoc::html_pretty:
        theme: cayman
        toc: true
        toc_depth: 3
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

<style>
body {
    text-align: justify;
}
</style>

# Introduction

<font size="4">

## What is the bugRzilla Package?

BugRzilla is an R package that helps the user to interact with the **Bugzilla** through an API.

<font size="3">To learn more, see [bugRzilla](https://github.com/llrs/bugRzilla).</font>

## About the bugRzilla Google Summer of COde Project:-

bugRzilla is a package to interact with a bugzilla API and specially with R bugzilla. The goal of the project is to help users to submit issues to R Bugzilla.

## About the This Project:-

Explore the issues and bugs on the R Bugzilla to make the submission from bugRzilla better. It might help to identify useful patterns for R core or report the status of the R Bugzilla.
</font>

<font size="3">To learn more, see [bugzilla_viz](https://github.com/llrs/bugzilla_viz).</font>

# Setup Database on your local system

## Download SQL and MySQL Workbench

<font size="4">
To install SQL on Ubuntu one can refer a blog post by [digitalocean](https://www.digitalocean.com/community/tutorials/how-to-install-mysql-on-ubuntu-20-04).
To install MySQL workbench on Ubuntu one can refer a blog post by [linuxhint](https://linuxhint.com/installing_mysql_workbench_ubuntu/)
</font>

## Download R_bugzilla data

<font size ="4">
<ol>
<li>
The R_bugzilla data can be downloaded from  [link](https://bugs.r-project.org/db/R-bugs.sql.xz).
</li>
<li>
Since the downloaded data is a zip file so make sure you unzip the file by directly using `extract here` option to the folder you desire before dumping the file
which will have an extension `.sql` (eg: R-bugs.sql).
</li>
</ol>
</font>

## Dump downloaded R_bugzilla to MySQL workbench.

<font size="4">
Before one import the R_bugzilla SQL file one needs to create the (empty) database from MySQL if it doesn't exist already and the exported SQL don't contain CREATE DATABASE (exported with --no-create-db or -n option), before you can import it.


After considering this open your Terminal and run the command: `mysqldump -u my_username -p database_name > output_file_path`
or you can use mysql using the command: `source <Path>/R-bugs.sql;`


The options in use are:
<ol>
    <li>
        The `-u` flag indicates that the MySQL `username` will follow.
    </li>
    <li>
        The `-p` flag indicates we should be prompted for the `password` associated with the above username.
    `database_name` is of course the exact name of the database to export. eg. `bugRzilla` is the empty database you created.
    </li>
    <li>
        The `>` symbol is a Unix directive for `STDOUT`, which allows Unix commands to output the text results of the issued command to another location. In this case, that output location is a file path, specified by `output_file_path`.
    </li>
</ol>

For Example,
<ol>
    <li>
        At the command prompt, run the following command to launch the mysql shell and enter it as the root user:
        `mysql -u root -p`
    </li>
    <li>
        When you’re prompted for a password, enter the one that you set at installation time, or if you haven’t set one, press Enter to submit no password.
        The following mysql shell prompt should appear:
        `mysql>`
    </li>
    <li>
        In MySQL, I used this to dump the data in the empty database: 
        <ul>
            <li>
                Create an empty database: `create database bugRzilla;`
            </li>
            <li>
                To check wheather the database is created or not use: `show databases;`
            </li>
            <li>
                Once an empty database is created then to dump the SQL data in the database use: `source /home/data/Documents/GSOC/R-bugs.sql;`
            </li>
            <li>
                To check your database is dumped correctly use: `show tables;`
```{r, eval=F}
mysql> show tables;
+---------------------+
| Tables_in_bugRzilla |
+---------------------+
| attachments         |
| bugs                |
| bugs_activity       |
| bugs_fulltext       |
| bugs_mod            |
| components          |
| longdescs           |
+---------------------+
7 rows in set (0.00 sec)
```
</li>
</ul>
</li>
</ol>
</font>

# bugRzilla Analysis

<font size="4">
For the connection to the database, I'm using the `dplyr` package, it supports to the widely-used open source databases like `MySQL`.
</font>

## The libraries used for the analysis:

```{r, }
# loading packages
library(dplyr)
library(dbplyr)
library(RMySQL)
library(DBI)
library(DT)
library(tidyverse)
library(skimr)
library(ggplot2)
library(plotly)
```

## Connect bugRzilla SQL Database with R

```{r}
# Connecting R with MySQL
con <- dbConnect(
    MySQL(),
    dbname='bugRzilla', # change the database name to your database name
    username='root', # change the username to your username
    password='1204', # update your password
    host='localhost',
    port=3306)

#  Accessing Tables names from the Database
DBI::dbListTables(con)
```

## Data Exploartion of Bugs Table from the Database
```{r}
bugs_df <- tbl(con, "bugs")
#for quick view of the datatypes and the structure of data
skim(bugs_df)
```
<font size="4">
From the above table we can conclude that the few of the columns are having wrong datatype like:
<ol>
    <li>
        creation_ts
    </li>
    <li>
        delta_ts
    </li>
    <li>
        lastdiffed
    </li>
    <li>
        estimated_time
    </li>
    <li>
        remaining_time
    </li>
    <li>
        deadline
    </li>
</ol>
**Note**:The Column `estimated_time` and `remaining_time` only contains the integer value. So, It can't be transformed to Date format datatype.
Also there are columns which are empty so they are of no use of the analysis like:
<ol>
    <li>
        target_milestone
    </li>
    <li>
        qa_contact
    </li>
    <li>
        status_whiteboard
    </li>
</ol>
</font>

```{r}
# Converting `bugs_df` to `dataframe`
bugs_df <- as.data.frame(bugs_df)
```

### Cleaning the data

<font size="4">
    First steps, check the data and prepare it for what we want:
</font>

```{r}
#converting the required fields in the correct datatype format
bugs_df <- bugs_df %>%
    mutate_at(vars("creation_ts", "delta_ts", "lastdiffed", "deadline"), as.Date)
# Taking the columns which are useful
bugs_df <- bugs_df %>%
    select("bug_id", "bug_severity", "bug_status", "creation_ts", "delta_ts", "op_sys", "priority", "resolution", "component_id", "version", "lastdiffed", "deadline")
#for quick view of the datatypes and the structure of data
skim(bugs_df)
#showing the `datatable`
datatable(head(bugs_df, 5), options = list(scrollX = TRUE))
```

### About the Bugs Data used for Analysis

<font size="4">
I've taken the 12 columns under consideration to Analyse the Data. The brief description about the columns as follows:
<ol>
    <li>
        **bug_id: **Unique numeric identifier for bug.
    </li>
    <li>
        **bug_severity: **How severe the bug is, e.g. enhancement, critical, etc.
    </li>
    <li>
        **bug_status: **Current status, e.g. NEW, RESOLVED, etc.
    </li>
    <li>
        **creation_ts: **When bug was filed.
    </li>
    <li>
        **delta_ts: **The timestamp of the last update on the bug. This includes updates to some related tables (e.g. "longdescs").
    </li>
    <li>
        **op_sys: **Operating system bug was seen on, e.g. Windows Vista, Linux, etc.
    </li>
    <li>
        **priority: **The priority of the bug (P1 = most urgent, P5 = least urgent).
    </li>
    <li>
        **resolution: **The resolution, if the bug is in a closed state, e.g. FIXED, DUPLICATE, etc.
    </li>
    <li>
        **component_id: **Numeric ids of the components.
    </li>
    <li>
        **version: **Version of software in which bug is seen.
    </li>
    <li>
        **lastdiffed: **The time at which information about this bug changing was last emailed to the cc list.
    </li>
    <li>
        **deadline: **Date by which bug must be fixed.
    </li>
</ol>
</font>

### Visualizations

```{r}
# Plotting the Bar graph and adding Trace of Time-Series graph with bug_id and creation_ts to see the spread
data <- data.frame(bugs_df$bug_id, bugs_df$creation_ts)
fig1 <- plot_ly(data,
                x = ~bugs_df$creation_ts,
                y = ~bugs_df$bug_id,
                type = 'scatter',
                mode = 'markers')
fig1 <- plot_ly(data,
                x = ~bugs_df$creation_ts,
                y = ~bugs_df$bug_id,
                type = 'bar',
                name = "bug_creation bar")
fig1 <- fig1 %>%
    add_trace(fig1,
              type = 'scatter',
              mode='lines+markers',
              name = "bug_creation Time_series")
fig1
```

<font size="4">
From the above the visualizations, The `Time-series graph` shows that which bug_id was filed in which `month` and `year` and from the `bar graph` we can conclude that in which `year` the most bugs are filed and when one will zoom the graphs, one can see on which date which bug was filed. The most of the Bugs are filled in the month of `January` and `July`.
</font>

```{r}
# Plotting the Time Series graph with the bug_id and delta_ts
data <- data.frame(bugs_df$bug_id, bugs_df$delta_ts)
fig2 <- plot_ly(data, 
                x = ~bugs_df$delta_ts, 
                y = ~bugs_df$bug_id, 
                type = 'scatter', 
                mode = 'markers')
fig2
```

<font size="4">
From the above the visualizations, The `Time-series graph` shows that which bug_id was last update. Most of the bugs are last updated in the month of `January`,`March`, `April`, and `July`.
</font>

```{r}
# Plotting bar graph with bug_id and resolution
data <- data.frame(bugs_df$bug_id, bugs_df$resolution)
fig4 <- plot_ly(data,
                x = ~bugs_df$resolution,
                y = ~bugs_df$bug_id,
                type = 'bar')
fig4
```

<font size="4">
From the above the visualizations, The `Resolution bar-graph` shows that which bug_id belongs to which category of resolution, if the bug is in a closed state, e.g. FIXED, DUPLICATE, etc. As we can conclude, that most bugs belongs to the fixed category of the resolution.
</font>

```{r}
# Plotting bar graph with bug_id and bug_status
data <- data.frame(bugs_df$bug_id, bugs_df$bug_status)
fig5 <- plot_ly(data,
                x = ~bugs_df$bug_status,
                y = ~bugs_df$bug_id,
                type = 'bar')
fig5
```

<font size="4">
From the above the visualizations, The `bug_status bar-graph` shows that which bug_id belongs to which category of bug_status, e.g. NEW, RESOLVED, etc. As we can conclude, that most bugs belongs to the closed category of the bug_status.
</font>

```{r}
# Plotting bar graph with bug_id and bug_severity
data <- data.frame(bugs_df$bug_id, bugs_df$bug_severity)
fig6 <- plot_ly(data,
                x = ~bugs_df$bug_severity,
                y = ~bugs_df$bug_id,
                type = 'bar')
fig6
```

<font size="4">
From the above the visualizations, The `bug_severity bar-graph` shows that which bug_id belongs to which category of bug_severity. Most of the bug which are filed are normal, some of the bugs which are filled under enhancements are retested for some features, minor and major and a very few bugs are filed under the blocker category.
</font>

## Data Exploartion of `bugs_activity` and `Attachments` Table from the Database
```{r}
bugs_act_df <- tbl(con, "bugs_activity")
# Converting `bugs_act_df` to `dataframe`
bugs_act_df <- as.data.frame(bugs_act_df)
#for quick view of the datatypes and the structure of data
skim(bugs_act_df)
```

### cleaing bugs_activity data

```{r}
bugs_act_df <- bugs_act_df %>%
    mutate_at(vars("bug_when"), as.Date)
```

```{r}
bugs_attach_df <- tbl(con, "attachments")
# Converting `bugs_attach_df` to `dataframe`
bugs_attach_df <- as.data.frame(bugs_attach_df)
#for quick view of the datatypes and the structure of data
skim(bugs_attach_df)
```
### Cleaning attachments Data

```{r}
bugs_attach_df <- bugs_attach_df %>%
    mutate_at(vars("creation_ts", "modification_time"), as.Date) %>%
    mutate_at(vars("isobsolete", "isprivate", "ispatch"), as.logical)
```

### Joining the `bugss`, `attachments` and `bugs_activity` tables

```{r}
#joining the `attachments` and `bugs_activity` table
baa <- merge(bugs_attach_df, bugs_act_df, by = intersect(names(bugs_act_df), names(bugs_attach_df)), all = TRUE)
#joining the `baa` and `bugs` table
baa <- merge(baa, bugs_df, by = intersect(names(baa), names(bugs_df)), all = TRUE)

#showing the baa i.e `attachments` and `bugs_activity` joined table in the `datatable`
datatable(baa, options = list(scrollX = TRUE))
```
```{r}
#for quick view of the datatypes and the structure of data
skim(baa)
```

### About the bugs_activity and attachments Data Used for Analysis

<font size="4">
    I've taken the 9 columns under consideration to Analyse the Data. The brief description about the columns as follows:
    <ol>
        <li>
            **bug_id: **Unique numeric identifier for bug.
        </li>
        <li>
            **attach_id: **Unique numeric identifier for attachment.
        </li>
        <li>
            **creation_ts: **When bug was filed.
        </li>
        <li>
            **modification_time: **The date and time on which the attachment was last modified.
        </li>
        <li>
            **description: **Text describing the attachment.
        </li>
        <li>
            **mimetype: **Content type of the attachment like `text/plain` or `image/png`.
        </li>
        <li>
            **ispatch: **Whether attachment is a patch.
        </li>
        <li>
            **filename :**Path-less file-name of attachment.
        </li>
        <li>
            **submitter_id: **Unique numeric identifier for who submitted the bug.
        </li>
        <li>
            **isobsolete: **Whether attachment is marked obsolete.
        </li>
        <li>
            **isprivate: **`TRUE` if the attachment should be `private` and `FALSE` if the attachment should be `public`.
        </li>
        <li>
            **who: **Unique numeric identifier for the user who submitted the bug.
        </li>
        <li>
            **bug_when: **The resolution, if the bug is in a closed state, e.g. FIXED, DUPLICATE
        </li>
        <li>
            **added: **Values added, if any (comma-separated if multiple).
        </li>
        <li>
            **removed: **Values removed, if any (comma-separated if multiple).
        </li>
    </ol>
</font>

### Visualizations

```{r}
res_dupli <- baa %>%
    filter(resolution == "DUPLICATE")
data <- data.frame(res_dupli$bug_id, res_dupli$creation_ts)
fig7 <- res_dupli %>% 
    plot_ly(
        data = data,
        y = ~res_dupli$bug_id, 
        x = ~res_dupli$creation_ts,
        type = 'scatter',
        mode = 'markers'
    )
fig7 <- plot_ly(data,
                x = ~res_dupli$creation_ts,
                y = ~res_dupli$bug_id,
                type = 'bar',
                name = "Duplicate_Bugs Bar")
fig7 <- fig7 %>%
    add_trace(fig7,
              type = 'scatter',
              mode='lines+markers',
              name = "Duplicate_Bugs Time_series")
fig7 <- fig7 %>%
    layout(
        title = "Duplicate Bugs",
        yaxis = list(title = "Bug_id"),
        xaxis = list(title = "Creation_time"),
        autosize = FALSE, margin = res_dupli$bug_id
    )
fig7
```

<font size = 4>
    The above above Visualization is about the when the Duplicate bugs were filed, from the graph we can see that the most wast filled from `2011` to `2014`. In `January` and `July` the frequency of the Duplicate bugs are more than other months of the year.
<font>

```{r}
res_fixed <- baa %>%
    filter(resolution == "FIXED")
diff_time <- rnorm(difftime(res_fixed$lastdiffed, res_fixed$creation_ts, units = "weeks"))
data <- data.frame(res_fixed$bug_id, diff_time)
fig8 <- plot_ly(
   data,
   x = ~diff_time,
   y = ~res_fixed$bug_id,
   type = "histogram",
   alpha = 0.6, nbinsx = 30,
   name = "bug_creation bar"
)
fig8 <- fig8 %>%
    layout(
        title = "Time Taken to Fix Bugs",
        yaxis = list(title = "Bug_id"),
        xaxis = list(title = "Week Frequency"),
        autosize = FALSE
    )
fig8
```

<font size = 4>
    The above above Histogram graph is about the how many weeks does a bug to get it fixed. From the graph we can see that most of the bug are fixed under `150 weeks`.
<font>

```{r}
res_invalid <- baa %>%
    filter(resolution == "INVALID")
data <- data.frame(res_invalid$bug_id, res_invalid$creation_ts)
fig9 <- plot_ly(
    data,
    x = ~res_invalid$creation_ts,
    y = ~res_invalid$bug_id,
    type = 'bar',
    name = "bug_creation bar"
)
fig9 <- fig9 %>%
    add_trace(
        fig7,
        type = 'scatter',
        mode='lines+markers',
        name = "bug_creation Time_series"
    )
fig9 <- fig9 %>%
    layout(
        title = "Invalid Bugs",
        yaxis = list(title = "Bug_id"),
        xaxis = list(title = "Creation_time"),
        autosize = FALSE, margin = res_invalid$bug_id
    )
fig9
```

This Visualization refers to the Creation of the Invalid bugs. In the Year `2010` to `2016` the Invalid bugs are filed.

## Data Exploartion of bugs_mod Table from the Database

```{r}
bugs_mod_df <- tbl(con, "bugs_mod")
# Converting `bugs_mod_df to `dataframe`
bugs_mod_df <- as.data.frame(bugs_mod_df)
#for quick view of the datatypes and the structure of data
skim(bugs_mod_df)
```

```{r}
#showing the baa i.e `bugs_mod_df` table in the `datatable`
datatable(bugs_mod_df, options = list(scrollX = TRUE))
```

## Data Exploartion of longdescs Table from the Database

```{r}
longdescs_df <- tbl(con, "longdescs")
# Converting `longdescs_df` to `dataframe`
longdescs_df <- as.data.frame(longdescs_df)
#for quick view of the datatypes and the structure of data
skim(longdescs_df)
```

```{r}
#showing the baa i.e `longdescs_df` table in the `datatable`
datatable(head(longdescs_df, 5), options = list(scrollX = TRUE))
```

```{r}
dbDisconnect(con )
```
